/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package event;

import java.io.*;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.lwjgl.util.vector.Vector3f;
import org.newdawn.slick.util.ResourceLoader;

/**
 *
 * @author Andy
 */
public class TerrainGenerator {

    static String path = "";
    static int sectionx = 9, sectionz = 9;

    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(path + ".obj"));
            BufferedWriter writer = new BufferedWriter(new FileWriter(path + "_fixed.obj"));
            String currentLine;
            ArrayList<Vector3f> verts = new ArrayList<Vector3f>();
            ArrayList<int[]> faces = new ArrayList<int[]>();
            ArrayList<String> faceLines = new ArrayList<String>();
            float minX = Float.MAX_VALUE, minY = Float.MAX_VALUE, minZ = Float.MAX_VALUE;
            float maxX = -Float.MAX_VALUE, maxY = -Float.MAX_VALUE, maxZ = -Float.MAX_VALUE;
            while ((currentLine = reader.readLine()) != null) {
                if (currentLine.startsWith("v ")) {
                    float x = Float.valueOf(currentLine.split(" ")[1]);
                    float y = Float.valueOf(currentLine.split(" ")[2]);
                    float z = Float.valueOf(currentLine.split(" ")[3]);
                    verts.add(new Vector3f(x, y, z));

                    if (x < minX) {
                        minX = x;
                    }
                    if (y < minY) {
                        minY = y;
                    }
                    if (z < minZ) {
                        minZ = z;
                    }

                    if (x > maxX) {
                        maxX = x;
                    }
                    if (y > maxY) {
                        maxY = y;
                    }
                    if (z > maxZ) {
                        maxZ = z;
                    }

                }
                if (currentLine.startsWith("f ")) {
                    faces.add(new int[]{
                                Integer.parseInt(currentLine.split(" ")[1].split("/")[0]) - 1,
                                Integer.parseInt(currentLine.split(" ")[2].split("/")[0]) - 1,
                                Integer.parseInt(currentLine.split(" ")[3].split("/")[0]) - 1
                            });
                    faceLines.add(currentLine);
                } else {
                    writer.write(currentLine);
                }
            }
            ArrayList<Point> grid = new ArrayList<Point>();
            float multX = sectionx / (maxX - minX);
            float multZ = sectionz / (maxZ - minZ);
            for (Vector3f v : verts) {
                grid.add(new Point((int) ((v.getX() - minX) * multX), (int) ((v.getZ() - minZ) * multZ)));
            }

            ArrayList[][] faceIndices = new ArrayList[sectionx][sectionz];
            for (int i = 0; i < faces.size(); i++) {
                int[] vertecies = faces.get(i);
                ArrayList<Point> face = new ArrayList<Point>();
                for (int index : vertecies) {
                    Point p = grid.get(index);
                    if (!face.contains(p)) {
                        int x = p.getX();
                        int z = p.getZ();
                        faceIndices[x][z].add(i);
                        face.add(p);
                    }
                }
            }

            for (int i = 0; i < faceIndices.length; i++) {
                for (int j = 0; j < faceIndices[i].length; j++) {
                    writer.write("#" + i + " " + j);
                    for (int k = 0; k < faceIndices[i][j].size(); k++) {
                        int faceIndex = (Integer) faceIndices[i][j].get(k);
                        String line = faceLines.get(faceIndex);
                        writer.write(line);
                    }
                }
            }
            reader.close();
            writer.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
}
